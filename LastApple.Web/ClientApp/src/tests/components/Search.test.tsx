import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { Search } from '../../components/Search';

interface TestItem {
  id: string;
  name: string;
  label?: string;
}

describe('Search', () => {
  const mockSearch = jest.fn();
  const mockOnChanged = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders without crashing', () => {
    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search artists..."
        onChanged={mockOnChanged}
      />
    );
  });

  it('renders with correct placeholder', () => {
    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Test placeholder"
        onChanged={mockOnChanged}
      />
    );

    expect(screen.getByPlaceholderText('Test placeholder')).toBeInTheDocument();
  });

  it('applies correct element index class', () => {
    const { container } = render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
        elementIndex={3}
      />
    );

    expect(container.querySelector('.search-control-3')).toBeInTheDocument();
  });

  it('defaults to element index 0 when not provided', () => {
    const { container } = render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
      />
    );

    expect(container.querySelector('.search-control-0')).toBeInTheDocument();
  });

  it('calls search function with delay when typing', async () => {
    mockSearch.mockResolvedValue([
      { id: '1', name: 'Test Artist', label: 'Test Artist' }
    ]);

    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
      />
    );

    const input = screen.getByPlaceholderText('Search');
    fireEvent.change(input, { target: { value: 'test query' } });

    // Wait for the delay (500ms) and the search to be called
    await waitFor(() => {
      expect(mockSearch).toHaveBeenCalledWith('test query');
    }, { timeout: 1000 });
  });

  it('shows loading state during search', async () => {
    // Mock a delayed search response
    mockSearch.mockImplementation(() => 
      new Promise(resolve => setTimeout(() => resolve([]), 200))
    );

    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
      />
    );

    const input = screen.getByPlaceholderText('Search');
    fireEvent.change(input, { target: { value: 'test' } });

    // The AsyncTypeahead component should show loading state
    // This is handled internally by react-bootstrap-typeahead
    await waitFor(() => {
      expect(mockSearch).toHaveBeenCalled();
    });
  });

  it('calls onChanged when selection changes', async () => {
    const testItems = [
      { id: '1', name: 'Artist 1', label: 'Artist 1' },
      { id: '2', name: 'Artist 2', label: 'Artist 2' }
    ];

    mockSearch.mockResolvedValue(testItems);

    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
        labelAccessor="name"
      />
    );

    const input = screen.getByPlaceholderText('Search');
    fireEvent.change(input, { target: { value: 'Artist' } });

    await waitFor(() => {
      expect(mockSearch).toHaveBeenCalledWith('Artist');
    });

    // Simulate selection (this would normally be done by the typeahead component)
    // Since we can't easily test the internal selection mechanism of AsyncTypeahead,
    // we'll just verify the component renders correctly
  });

  it('handles empty search results', async () => {
    mockSearch.mockResolvedValue([]);

    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
      />
    );

    const input = screen.getByPlaceholderText('Search');
    fireEvent.change(input, { target: { value: 'no results' } });

    await waitFor(() => {
      expect(mockSearch).toHaveBeenCalledWith('no results');
    });
  });

  it('uses custom label accessor when provided', () => {
    render(
      <Search<TestItem>
        search={mockSearch}
        placeholder="Search"
        onChanged={mockOnChanged}
        labelAccessor="name"
      />
    );

    // The labelAccessor prop should be passed to AsyncTypeahead
    // We can't easily verify this without accessing internal props,
    // but the component should render without errors
    expect(screen.getByPlaceholderText('Search')).toBeInTheDocument();
  });
});